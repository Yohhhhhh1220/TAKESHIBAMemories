<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TAKESHIBA Memories</title>
    <link rel="stylesheet" href="/styles.css">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&family=Shippori+Mincho:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <canvas id="background-canvas" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; display: block; z-index: -1;"></canvas>
    <div class="container">
        <header class="header">
            <img src="/logo.png" alt="" class="logo" onerror="this.style.display='none';">
            <p class="subtitle">感情が見える聞こえる街に</p>
        </header>
        
        <main class="main">
            <!-- 川柳生成セクション -->
            <div class="haiku-generation-section">
                <div class="section-header">
                    <h2>🎋 新しい川柳を作る</h2>
                    <p>あなたの今をAIが川柳にします<br>みんなと共有してみませんか？</p>
                </div>
                
                <div class="survey-container">
                    <form id="survey-form" class="survey-form">
                        <div class="form-group">
                            <label for="purpose">あなたは何をしに竹芝に来ましたか？</label>
                            <select id="purpose" name="purpose" required>
                                <option value="">選択してください</option>
                                <option value="work">仕事</option>
                                <option value="meeting">会議・打ち合わせ</option>
                                <option value="study">学校・勉強</option>
                                <option value="dining">食事・カフェ</option>
                                <option value="shopping">お買い物</option>
                                <option value="art">舞台や芸術を観に</option>
                                <option value="ship">船に乗るため</option>
                                <option value="event">イベント等の参加</option>
                                <option value="hotel">ホテルに宿泊</option>
                                <option value="walk">お散歩・リフレッシュ</option>
                                <option value="date">デート</option>
                                <option value="exercise">運動・通りすがり・休憩</option>
                                <option value="other">その他</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label for="mood">あなたの今の気分を1つ選びましょう！</label>
                            <div class="mood-options">
                                <div class="mood-option" data-mood="exhilarated">
                                    <span class="mood-emoji">🚀</span>
                                    <span class="mood-text">高揚している</span>
                                </div>
                                <div class="mood-option" data-mood="excited">
                                    <span class="mood-emoji">🤩</span>
                                    <span class="mood-text">わくわくする</span>
                                </div>
                                <div class="mood-option" data-mood="inspired">
                                    <span class="mood-emoji">✨</span>
                                    <span class="mood-text">刺激的だ</span>
                                </div>
                                <div class="mood-option" data-mood="joyful">
                                    <span class="mood-emoji">😊</span>
                                    <span class="mood-text">楽しい</span>
                                </div>
                                <div class="mood-option" data-mood="calm">
                                    <span class="mood-emoji">😌</span>
                                    <span class="mood-text">穏やか</span>
                                </div>
                                <div class="mood-option" data-mood="relaxed">
                                    <span class="mood-emoji">🧘</span>
                                    <span class="mood-text">リラックス</span>
                                </div>
                                <div class="mood-option" data-mood="content">
                                    <span class="mood-emoji">😌</span>
                                    <span class="mood-text">満たされている</span>
                                </div>
                                <div class="mood-option" data-mood="hopeful">
                                    <span class="mood-emoji">🌟</span>
                                    <span class="mood-text">前向きな気分</span>
                                </div>
                                <div class="mood-option" data-mood="melancholy">
                                    <span class="mood-emoji">😔</span>
                                    <span class="mood-text">憂鬱だ</span>
                                </div>
                                <div class="mood-option" data-mood="lonely">
                                    <span class="mood-emoji">😢</span>
                                    <span class="mood-text">孤独を感じる</span>
                                </div>
                                <div class="mood-option" data-mood="tired">
                                    <span class="mood-emoji">😴</span>
                                    <span class="mood-text">疲れている</span>
                                </div>
                                <div class="mood-option" data-mood="apathetic">
                                    <span class="mood-emoji">😑</span>
                                    <span class="mood-text">無気力だ</span>
                                </div>
                                <div class="mood-option" data-mood="anxious">
                                    <span class="mood-emoji">😰</span>
                                    <span class="mood-text">焦っている</span>
                                </div>
                                <div class="mood-option" data-mood="tense">
                                    <span class="mood-emoji">😬</span>
                                    <span class="mood-text">緊張している</span>
                                </div>
                                <div class="mood-option" data-mood="irritated">
                                    <span class="mood-emoji">😠</span>
                                    <span class="mood-text">いらいらする</span>
                                </div>
                                <div class="mood-option" data-mood="surprised">
                                    <span class="mood-emoji">😲</span>
                                    <span class="mood-text">驚いている</span>
                                </div>
                            </div>
                            <input type="hidden" id="mood" name="mood" required>
                        </div>
                        
                        <div class="form-group">
                            <label for="reason">なぜその気分なのですか？</label>
                            <textarea id="reason" name="reason" placeholder="その気分になった理由を教えてください..." required></textarea>
                        </div>
                        
                        <div class="form-group">
                            <label for="penname">ペンネーム</label>
                            <input type="text" id="penname" name="penname" placeholder="無記入の場合は「詠み人知らず」と表示されます" maxlength="20">
                        </div>
                        
                        <div class="form-group privacy-group">
                            <div class="privacy-checkbox-container">
                                <input type="checkbox" id="privacy-agree" name="privacy-agree" required>
                                <label for="privacy-agree" class="privacy-label">
                                    <a href="#" id="privacy-link" class="privacy-link">【プライバシーポリシー】</a>に同意します。
                                </label>
                            </div>
                            <p class="privacy-notice">作成された川柳は、ビル内に設置されたディスプレイに表示される可能性があります。<br>本名や連絡先など、個人情報は絶対に入力しないでください。<br>個人を特定できる情報は収集していません。</p>
                        </div>
                        
                        <div class="form-actions">
                            <button type="submit" class="submit-btn" id="submit-btn" disabled>
                                <span class="btn-text">川柳を生成する</span>
                                <span class="btn-loading" style="display: none;">川柳生成中...</span>
                            </button>
                            <p class="generation-time-note">※川柳の生成には約5秒～10秒かかります</p>
                        </div>
                    </form>
                    
                    <div id="result-section" class="result-section" style="display: none;">
                        <div class="haiku-result">
                            <h3>あなたの川柳</h3>
                            <div class="haiku-display" id="haiku-display"></div>
                            <div class="haiku-info">
                                <p class="note">竹芝での思い出を川柳として記録しました。</p>
                            </div>
                            <div class="haiku-actions">
                                <button class="action-btn" id="new-haiku-btn">新しい川柳を作る</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- 他の人の川柳閲覧セクション -->
            <div class="haiku-gallery-section">
                <div class="section-header">
                    <h2>📜 みんなの川柳</h2>
                    <p>他の人が作った川柳を見てみましょう</p>
                </div>
                
                
                <div id="haiku-gallery" class="haiku-gallery">
                    <!-- 動的に川柳が表示されます -->
                </div>
                
                <div class="loading-indicator" id="loading-indicator" style="display: none;">
                    <div class="spinner"></div>
                    <p>川柳を読み込み中...</p>
                </div>
            </div>
            
            <!-- ディスプレイページへのリンク -->
            <div class="display-link-section">
                <a href="/display" class="display-link-btn">
                    <span class="display-icon">🖥️</span>
                    <span class="display-text">ディスプレイ表示</span>
                    <span class="display-subtext">縦長ディスプレイ用の表示</span>
                </a>
            </div>
        </main>
        
        <footer class="footer">
            <p>慶應義塾大学大学院メディアデザイン研究科</p>
            <p>MeLIGHT Project</p>
        </footer>
    </div>
    
    <!-- プライバシーポリシーモーダル -->
    <div id="privacy-modal" class="privacy-modal">
        <div class="privacy-modal-content">
            <div class="privacy-modal-header">
                <h2>プライバシーポリシー</h2>
                <button class="privacy-modal-close" id="privacy-modal-close">&times;</button>
            </div>
            <div class="privacy-modal-body" id="privacy-modal-body">
                <h3>プライバシーポリシー（個人情報の取り扱いについて）</h3>
                <p>本イベント主催者（以下、「当方」）は、本イベントにおいて提供する「AI川柳生成体験」（以下、「本サービス」）における利用者の情報の取り扱いについて、以下のとおり定めます。</p>
                
                <h3>第1条（取得する情報）</h3>
                <p>当方は、利用者が本サービスを利用する際に、以下の情報を取得します。</p>
                <ul>
                    <li>フォーム入力情報：ペンネーム、来訪理由、今の気分、その理由</li>
                    <li>自動取得情報：アクセス時間</li>
                </ul>
                
                <h3>第2条（利用目的）</h3>
                <p>取得した情報は、以下の目的で利用します。</p>
                <ul>
                    <li>AIによる川柳の生成および本サービスの提供のため</li>
                    <li>生成された川柳および入力内容（ペンネーム等）を、イベント会場内のディスプレイ（サイネージ）やWebサイト等で公開・展示するため</li>
                    <li>本サービスの改善、利用状況の分析、および研究活動のため</li>
                </ul>
                
                <h3>第3条（入力データの公開に関する注意）</h3>
                <p>本サービスで生成された川柳およびペンネームは、会場内のディスプレイにて不特定多数の第三者に公開されます。そのため、入力フォーム（特に「今の気分」や「その理由」等の自由記述欄）には、本名、住所、電話番号などの個人を特定できる情報（個人情報）や、他人に知られたくないプライベートな内容は絶対に入力しないでください。</p>
                
                <h3>第4条（外部AIサービスの利用）</h3>
                <p>本サービスは、コンテンツ生成のためにOpenAI社の提供するAIサービスを利用しています。入力されたデータはAPIを通じて同社に送信されますが、当方は同社に対し、当該データをAIモデルの学習に使用しない設定（またはポリシーに基づいた利用）で運用を行います。</p>
                
                <h3>第5条（免責事項）</h3>
                <p>利用者が本サービスに入力した情報によって生じたトラブルや損害について、当方は一切の責任を負いません。また、公序良俗に反する内容や不適切な内容が含まれると判断した場合、当方は予告なく生成・表示を中止する権利を有します。</p>
                
                <h3>第6条（事業者情報・お問い合わせ）</h3>
                <p>本サービスおよび本ポリシーに関するお問い合わせは、以下までお願いいたします。</p>
                <p>
                    慶應義塾大学大学院メディアデザイン研究科所属 磯村 要<br>
                    メールアドレス：<a href="mailto:isomurayo1220@keio.jp">isomurayo1220@keio.jp</a>
                </p>
                
                <p style="margin-top: 30px; text-align: right; font-size: 0.9rem; color: #666;">以上</p>
                <p style="text-align: right; font-size: 0.9rem; color: #666;">策定日：2025年12月18日</p>
            </div>
        </div>
    </div>
    
    <!-- 背景マーブル水滴エフェクト -->
    <script>
        (function () {
            const canvas = document.getElementById('background-canvas');
            const gl = canvas && canvas.getContext('webgl2');

            if (!canvas || !gl) {
                console.warn('WebGL2がサポートされていないため、背景エフェクトは無効になります。');
                return;
            }

            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            const MAX_DROPLETS = 100;
            const droplets = [];

            const vertexShaderSource = `#version 300 es
                in vec2 position;
                void main() {
                    gl_Position = vec4(position, 0.0, 1.0);
                }
            `;

            const fragmentShaderSource = `#version 300 es
                precision highp float;
                
                uniform vec2 iResolution;
                uniform float iTime;
                uniform vec4 droplets[${MAX_DROPLETS}];
                uniform int dropletCount;
                
                out vec4 fragColor;

                vec4 mod289(vec4 x) { return x - floor(x * (1.0/289.0)) * 289.0; }
                vec4 permute(vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }
                vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
                vec2 fade(vec2 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }

                float cnoise(vec2 P) {
                    vec4 Pi = floor(P.xyxy) + vec4(0.0,0.0,1.0,1.0);
                    vec4 Pf = fract(P.xyxy) - vec4(0.0,0.0,1.0,1.0);
                    Pi = mod289(Pi);
                    vec4 ix = Pi.xzxz;
                    vec4 iy = Pi.yyww;
                    vec4 fx = Pf.xzxz;
                    vec4 fy = Pf.yyww;
                    vec4 i = permute(permute(ix) + iy);
                    vec4 gx = fract(i * (1.0/41.0)) * 2.0 - 1.0;
                    vec4 gy = abs(gx) - 0.5;
                    vec4 tx = floor(gx + 0.5);
                    gx = gx - tx;
                    vec2 g00 = vec2(gx.x, gy.x);
                    vec2 g10 = vec2(gx.y, gy.y);
                    vec2 g01 = vec2(gx.z, gy.z);
                    vec2 g11 = vec2(gx.w, gy.w);
                    vec4 norm = taylorInvSqrt(vec4(dot(g00,g00), dot(g01,g01), dot(g10,g10), dot(g11,g11)));
                    g00 *= norm.x; g01 *= norm.y; g10 *= norm.z; g11 *= norm.w;
                    float n00 = dot(g00, vec2(fx.x, fy.x));
                    float n10 = dot(g10, vec2(fx.y, fy.y));
                    float n01 = dot(g01, vec2(fx.z, fy.z));
                    float n11 = dot(g11, vec2(fx.w, fy.w));
                    vec2 fade_xy = fade(Pf.xy);
                    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);
                    return 2.3 * mix(n_x.x, n_x.y, fade_xy.y);
                }

                const int OCTAVES = 8;
                float fbm(vec2 p, float waveFrequency, float waveAmplitude) {
                    float value = 0.0;
                    float amp = 1.0;
                    float freq = waveFrequency;
                    for (int i = 0; i < OCTAVES; i++) {
                        value += amp * abs(cnoise(p));
                        p *= freq;
                        amp *= waveAmplitude;
                    }
                    return value;
                }

                float pattern(vec2 p, float time, float waveSpeed, float waveFrequency, float waveAmplitude) {
                    vec2 p2 = p - time * waveSpeed;
                    return fbm(p - fbm(p + fbm(p2, waveFrequency, waveAmplitude), waveFrequency, waveAmplitude), waveFrequency, waveAmplitude);
                }

                float bayerMatrix8x8(int x, int y) {
                    const int matrix[64] = int[64](
                        0, 48, 12, 60, 3, 51, 15, 63,
                        32, 16, 44, 28, 35, 19, 47, 31,
                        8, 56, 4, 52, 11, 59, 7, 55,
                        40, 24, 36, 20, 43, 27, 39, 23,
                        2, 50, 14, 62, 1, 49, 13, 61,
                        34, 18, 46, 30, 33, 17, 45, 29,
                        10, 58, 6, 54, 9, 57, 5, 53,
                        42, 26, 38, 22, 41, 25, 37, 21
                    );
                    return float(matrix[y * 8 + x]) / 64.0;
                }

                vec3 dither(vec2 fragCoord, vec3 color, float colorNum) {
                    int x = int(fragCoord.x) % 8;
                    int y = int(fragCoord.y) % 8;
                    float threshold = bayerMatrix8x8(x, y) - 0.25;
                    color += threshold;
                    return floor(color * (colorNum - 1.0) + 0.5) / (colorNum - 1.0);
                }

                void main() {
                    vec2 uv = gl_FragCoord.xy / iResolution.xy;
                    uv -= 0.5;
                    uv.x *= iResolution.x / iResolution.y;
                    
                    vec3 lightBlue = vec3(0.13, 0.5, 0.85);
                    vec3 pink = vec3(1.0, 0.2, 0.5);
                    vec3 white = vec3(0.8, 0.9, 1.0);
                    
                    vec3 col = white;
                    
                    // 波紋の干渉パターンを蓄積
                    float totalWaveHeight = 0.0;
                    vec2 flowField = vec2(0.0);
                    vec3 accumulatedColor = vec3(0.0);
                    float totalColorWeight = 0.0;
                    
                    // 各水滴からの永続的な波紋
                    for (int i = 0; i < dropletCount && i < ${MAX_DROPLETS}; i++) {
                        vec4 droplet = droplets[i];
                        vec2 dropPos = droplet.xy;
                        float dropTime = droplet.z;
                        float dropType = droplet.w;
                        
                        float elapsed = iTime - dropTime;
                        
                        if (elapsed >= 0.0) {
                            float dist = length(uv - dropPos);
                            
                            // ランダムサイズ
                            float sizeRandom = fract(sin(dropTime * 12.9898) * 43758.5453);
                            float sizeScale = 0.5 + sizeRandom * 1.0;
                            
                            float baseSpeed = 0.075; // 速度半分
                            float baseSize = 0.033 * sizeScale; // サイズ1/3
                            
                            // 永続的な波紋（消えない）
                            int numRipples = 5 + int(sizeRandom * 3.0);
                            float rippleWaveHeight = 0.0;
                            
                            for (int r = 0; r < 7; r++) {
                                if (r >= numRipples) break;
                                
                                float rippleDelay = float(r) * 0.15;
                                float rippleElapsed = elapsed - rippleDelay;
                                
                                if (rippleElapsed > 0.0) {
                                    float rippleRadius = rippleElapsed * baseSpeed;
                                    float rippleWidth = baseSize * 0.8;
                                    
                                    // 波紋の高さ（正弦波）
                                    float rippleDist = abs(dist - rippleRadius);
                                    float ripple = smoothstep(rippleWidth, rippleWidth * 0.3, rippleDist);
                                    
                                    // 時間減衰を緩やかに（長く残る）
                                    float decay = exp(-rippleElapsed * 0.15);
                                    ripple *= decay;
                                    
                                    // 波の位相
                                    float phase = sin(dist * 20.0 - rippleElapsed * 3.0) * ripple;
                                    rippleWaveHeight += phase * 0.4;
                                }
                            }
                            
                            totalWaveHeight += rippleWaveHeight;
                            
                            // 波紋による流れ場の生成（波が進む方向）
                            vec2 direction = normalize(uv - dropPos);
                            float flowStrength = abs(rippleWaveHeight) * 0.15;
                            flowField += direction * flowStrength;
                            
                            // 色の影響
                            float colorRadius = elapsed * baseSpeed * 3.0;
                            float colorDecay = exp(-elapsed * 0.12);
                            float colorInfluence = smoothstep(colorRadius, colorRadius * 0.1, dist) * colorDecay;
                            
                            if (colorInfluence > 0.01) {
                                vec3 dropColor = (dropType == 1.0) ? pink : lightBlue;
                                accumulatedColor += dropColor * colorInfluence;
                                totalColorWeight += colorInfluence;
                            }
                        }
                    }
                    
                    // 波紋の干渉が蓄積されて海流パターンを形成
                    if (abs(totalWaveHeight) > 0.1 || totalColorWeight > 0.1) {
                        // 流れ場によって座標を歪める
                        vec2 distortedUV = uv + flowField * 0.2;
                        
                        // 波の干渉強度に応じて海流パターンを生成
                        float interferenceStrength = clamp(abs(totalWaveHeight) * 2.0, 0.0, 1.0);
                        
                        // 海流風マーブルパターン
                        float waveSpeed = 0.05;
                        float waveFrequency = 3.0 + interferenceStrength * 1.5;
                        float waveAmplitude = 0.3 + interferenceStrength * 0.15;
                        
                        // 干渉が強いほどマーブル模様が顕著に
                        float marblePattern = pattern(
                            distortedUV + totalWaveHeight * 0.08, 
                            iTime, 
                            waveSpeed, 
                            waveFrequency, 
                            waveAmplitude
                        ) * interferenceStrength;
                        
                        // 単純な波紋と海流パターンをブレンド
                        float patternBlend = smoothstep(0.2, 0.8, interferenceStrength);
                        
                        if (totalColorWeight > 0.0) {
                            vec3 avgColor = accumulatedColor / totalColorWeight;
                            
                            // 海流パターンに基づく3段階の色
                            float combinedPattern = mix(
                                fract(totalWaveHeight * 5.0) * 0.5 + 0.5, 
                                marblePattern, 
                                patternBlend
                            );
                            
                            vec3 darkColor = avgColor * 0.4;
                            vec3 midColor = avgColor * 0.7;
                            vec3 brightColor = avgColor * 1.0;
                            
                            vec3 finalColor;
                            if (combinedPattern < 0.33) {
                                finalColor = mix(darkColor, midColor, combinedPattern / 0.33);
                            } else if (combinedPattern < 0.66) {
                                finalColor = mix(midColor, brightColor, (combinedPattern - 0.33) / 0.33);
                            } else {
                                finalColor = mix(brightColor, white, (combinedPattern - 0.66) / 0.34);
                            }
                            
                            // 波紋の干渉度合いに応じて色を適用
                            float colorIntensity = clamp(totalColorWeight * 0.7, 0.0, 1.0);
                            col = mix(white, finalColor, colorIntensity);
                        }
                    }
                    
                    // ディザリング
                    float colorNum = 4.0;
                    col = dither(gl_FragCoord.xy, col, colorNum);
                    
                    fragColor = vec4(col, 1.0);
                }
            `;

            function compileShader(source, type) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }
                return shader;
            }

            const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
            const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);

            if (!vertexShader || !fragmentShader) {
                return;
            }

            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program linking error:', gl.getProgramInfoLog(program));
                return;
            }

            gl.useProgram(program);

            const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
            const vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

            const positionLocation = gl.getAttribLocation(program, 'position');
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

            const iResolutionLocation = gl.getUniformLocation(program, 'iResolution');
            const iTimeLocation = gl.getUniformLocation(program, 'iTime');
            const dropletsLocation = gl.getUniformLocation(program, 'droplets');
            const dropletCountLocation = gl.getUniformLocation(program, 'dropletCount');

            function addDroplet(type) {
                const currentTime = performance.now() / 1000;
                const x = (Math.random() - 0.5) * 1.2;
                const y = (Math.random() - 0.5) * 1.2;

                if (droplets.length >= MAX_DROPLETS) {
                    droplets.shift();
                }

                droplets.push({ x, y, time: currentTime, type });
            }

            // 外部から呼び出すためのグローバル関数
            window.triggerPositiveEmotion = function () {
                addDroplet(1); // ピンク
            };
            window.triggerNegativeEmotion = function () {
                addDroplet(2); // ライトブルー
            };

            // テスト用：A / S キーで水滴を発生させる
            document.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                if (key === 'a') {
                    window.triggerPositiveEmotion();
                } else if (key === 's') {
                    window.triggerNegativeEmotion();
                }
            });

            function render() {
                const time = performance.now() / 1000;
                
                gl.uniform2f(iResolutionLocation, canvas.width, canvas.height);
                gl.uniform1f(iTimeLocation, time);
                
                const dropletData = new Float32Array(MAX_DROPLETS * 4);
                for (let i = 0; i < droplets.length; i++) {
                    dropletData[i * 4 + 0] = droplets[i].x;
                    dropletData[i * 4 + 1] = droplets[i].y;
                    dropletData[i * 4 + 2] = droplets[i].time;
                    dropletData[i * 4 + 3] = droplets[i].type;
                }
                
                gl.uniform4fv(dropletsLocation, dropletData);
                gl.uniform1i(dropletCountLocation, droplets.length);
                
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                requestAnimationFrame(render);
            }

            render();
        })();
    </script>
    <script src="/app.js"></script>
</body>
</html>