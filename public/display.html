<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å·æŸ³å±•ç¤º - TAKESHIBA Memories</title>
    <link rel="stylesheet" href="/styles.css">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&family=Shippori+Mincho:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* 2160Ã—3840ç¸¦é•·ãƒ‡ã‚£ã‚¹ãƒ—ãƒ¬ã‚¤å°‚ç”¨ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        body {
            margin: 0;
            padding: 0;
            background: #000; /* èƒŒæ™¯ã¯WebGLã‚­ãƒ£ãƒ³ãƒã‚¹ã§æç”»ã™ã‚‹ãŸã‚å˜è‰²ã« */
            font-family: 'Noto Sans JP', sans-serif;
            overflow-x: hidden;
            height: 100vh;
        }

        /* èƒŒæ™¯ç”¨WebGLã‚­ãƒ£ãƒ³ãƒã‚¹ */
        #background-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: block;
            z-index: -1; /* æ—¢å­˜ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®èƒŒé¢ã«é…ç½® */
        }

        .display-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px;
            box-sizing: border-box;
        }

        .display-header {
            text-align: center;
            margin-bottom: 50px;
            color: #333;
        }

        .display-title {
            font-size: 5rem;
            font-weight: 300;
            margin-bottom: 20px;
            letter-spacing: 0.1em;
        }

        .display-logo {
            max-width: 500px;
            width: 100%;
            height: auto;
            margin: 0 auto 20px;
            display: block;
        }

        .display-subtitle {
            font-size: 2.8rem;
            font-weight: 300;
            color: #000000;
            letter-spacing: 0.05em;
        }

        .haikus-container {
            width: 100%;
            max-width: 2000px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(600px, 1fr));
            gap: 60px;
            padding: 60px;
            overflow-y: auto;
            flex: 1;
        }

        .haiku-display-card {
            background: rgba(255, 255, 255, 0.95);
            padding: 100px 80px;
            border-radius: 40px;
            box-shadow: 
                0 30px 60px rgba(0,0,0,0.1),
                0 0 0 1px rgba(255,255,255,0.2);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(102, 126, 234, 0.1);
            position: relative;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .haiku-display-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #667eea, #764ba2);
        }

        .haiku-display-card:hover {
            transform: translateY(-5px);
            box-shadow: 
                0 40px 80px rgba(0,0,0,0.15),
                0 0 0 1px rgba(255,255,255,0.2);
        }

        .haiku-display-text {
            font-size: 3.5rem;
            line-height: 2.5;
            font-weight: bold;
            margin-bottom: 40px;
            letter-spacing: 0.1em;
            color: #2c3e50;
            text-shadow: 0 2px 4px rgba(0,0,0,0.1);
            font-family: 'Shippori Mincho', serif;
            min-height: 8em;
            display: flex;
            flex-direction: row-reverse; /* ç¸¦æ›¸ãã§ã¯è¡ŒãŒæ¨ªï¼ˆå³ã‹ã‚‰å·¦ï¼‰ã«ä¸¦ã¶ */
            justify-content: center;
            align-items: stretch;
            gap: 1.2em; /* è¡Œé–“ */
            height: auto;
            max-width: 100%;
        }
        
        .haiku-line {
            display: inline-block;
            writing-mode: vertical-rl; /* å„è¡Œæƒ…å ±ã‚’ç¸¦æ›¸ã */
            text-orientation: upright; /* æ–‡å­—ã‚’ç¸¦å‘ãã« */
            line-height: 1.8;
            letter-spacing: 0.2em;
        }

        .haiku-display-meta {
            display: flex;
            justify-content: space-between;
            font-size: 1.5rem;
            color: #7f8c8d;
            padding-top: 30px;
            border-top: 1px solid rgba(102, 126, 234, 0.1);
        }

        .loading-message {
            text-align: center;
            color: #7f8c8d;
            font-size: 2.5rem;
            padding: 100px;
        }

        .error-message {
            text-align: center;
            color: #e74c3c;
            font-size: 2.5rem;
            padding: 100px;
        }

        /* ç¸¦é•·ãƒ‡ã‚£ã‚¹ãƒ—ãƒ¬ã‚¤æœ€é©åŒ– */
        @media (min-width: 2160px) and (min-height: 3840px) {
            .haikus-container {
                grid-template-columns: repeat(2, 1fr);
                gap: 80px;
                padding: 100px;
            }

            .haiku-display-text {
                font-size: 4.5rem;
                line-height: 2.8;
                gap: 1.5em; /* è¡Œé–“ã‚’ç‹­ã‚ã‚‹ */
            }

            .display-logo {
                max-width: 600px;
                width: 100%;
                height: auto;
            }

            .display-subtitle {
                font-size: 3rem;
            }
        }

        /* æ¨ªé•·ãƒ‡ã‚£ã‚¹ãƒ—ãƒ¬ã‚¤å¯¾å¿œ */
        @media (min-width: 3840px) and (max-height: 2160px) {
            .haikus-container {
                grid-template-columns: repeat(3, 1fr);
                gap: 40px;
            }
        }

        /* é€šå¸¸ã®ãƒ‡ã‚£ã‚¹ãƒ—ãƒ¬ã‚¤å¯¾å¿œ */
        @media (max-width: 1920px) {
            .haikus-container {
                grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
                gap: 50px;
                padding: 50px;
            }

            .haiku-display-text {
                font-size: 3rem;
            }
        }

        /* ãƒ¢ãƒã‚¤ãƒ«ãƒ‡ãƒã‚¤ã‚¹ï¼ˆã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³ï¼‰å¯¾å¿œ - ç¸¦æ›¸ãè¡¨ç¤º */
        @media (max-width: 768px) {
            .display-container {
                padding: 20px;
            }

            .display-header {
                margin-bottom: 30px;
            }

            .display-title {
                font-size: 2rem;
            }

            .display-logo {
                max-width: 200px;
            }

            .display-subtitle {
                font-size: 1.5rem;
            }

            .haikus-container {
                grid-template-columns: 1fr;
                gap: 30px;
                padding: 20px;
            }

            .haiku-display-card {
                padding: 40px 30px;
                border-radius: 20px;
            }

            .haiku-display-text {
                font-size: 1.2rem;
                line-height: 1.8;
                min-height: auto;
                display: flex;
                flex-direction: row-reverse;
                justify-content: center;
                align-items: center;
                gap: 1em;
                width: 100%;
                padding: 20px;
                box-sizing: border-box;
                text-align: center;
            }

            .haiku-line {
                writing-mode: vertical-rl;
                text-orientation: upright;
                line-height: 1.8;
                letter-spacing: 0.2em;
                display: inline-block;
            }

            .haiku-display-meta {
                font-size: 0.7rem !important;
                flex-direction: column;
                gap: 10px;
                align-items: flex-start;
            }
            
            .haiku-display-meta .haiku-penname,
            .haiku-display-meta .haiku-timestamp {
                font-size: 0.7rem !important;
            }
            
            .haiku-display-actions {
                margin-top: 20px;
                padding-top: 15px;
            }
            
            .haiku-display-actions .like-btn {
                font-size: 1rem;
                padding: 12px 24px;
            }
            
            .haiku-display-actions .like-icon {
                font-size: 1.2rem;
            }
            
            .haiku-display-actions .like-count {
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>
    <canvas id="background-canvas"></canvas>
    <div class="display-container">
        <div class="display-header">
            <img src="/logo.png" alt="" class="display-logo" onerror="this.style.display='none';">
            <p class="display-subtitle">ã¿ã‚“ãªã®å·æŸ³</p>
        </div>
        
        <div class="haikus-container" id="haikus-container">
            <div class="loading-message">å·æŸ³ã‚’èª­ã¿è¾¼ã¿ä¸­...</div>
        </div>
    </div>

    <!-- èƒŒæ™¯ãƒãƒ¼ãƒ–ãƒ«æ°´æ»´ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ -->
    <script>
        (function () {
            const canvas = document.getElementById('background-canvas');
            const gl = canvas && canvas.getContext('webgl2');

            if (!canvas || !gl) {
                console.warn('WebGL2ãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„ãŸã‚ã€èƒŒæ™¯ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¯ç„¡åŠ¹ã«ãªã‚Šã¾ã™ã€‚');
                return;
            }

            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            const MAX_DROPLETS = 100;
            const droplets = [];

            const vertexShaderSource = `#version 300 es
                in vec2 position;
                void main() {
                    gl_Position = vec4(position, 0.0, 1.0);
                }
            `;

            const fragmentShaderSource = `#version 300 es
                precision highp float;
                
                uniform vec2 iResolution;
                uniform float iTime;
                uniform vec4 droplets[${MAX_DROPLETS}];
                uniform int dropletCount;
                
                out vec4 fragColor;

                vec4 mod289(vec4 x) { return x - floor(x * (1.0/289.0)) * 289.0; }
                vec4 permute(vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }
                vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
                vec2 fade(vec2 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }

                float cnoise(vec2 P) {
                    vec4 Pi = floor(P.xyxy) + vec4(0.0,0.0,1.0,1.0);
                    vec4 Pf = fract(P.xyxy) - vec4(0.0,0.0,1.0,1.0);
                    Pi = mod289(Pi);
                    vec4 ix = Pi.xzxz;
                    vec4 iy = Pi.yyww;
                    vec4 fx = Pf.xzxz;
                    vec4 fy = Pf.yyww;
                    vec4 i = permute(permute(ix) + iy);
                    vec4 gx = fract(i * (1.0/41.0)) * 2.0 - 1.0;
                    vec4 gy = abs(gx) - 0.5;
                    vec4 tx = floor(gx + 0.5);
                    gx = gx - tx;
                    vec2 g00 = vec2(gx.x, gy.x);
                    vec2 g10 = vec2(gx.y, gy.y);
                    vec2 g01 = vec2(gx.z, gy.z);
                    vec2 g11 = vec2(gx.w, gy.w);
                    vec4 norm = taylorInvSqrt(vec4(dot(g00,g00), dot(g01,g01), dot(g10,g10), dot(g11,g11)));
                    g00 *= norm.x; g01 *= norm.y; g10 *= norm.z; g11 *= norm.w;
                    float n00 = dot(g00, vec2(fx.x, fy.x));
                    float n10 = dot(g10, vec2(fx.y, fy.y));
                    float n01 = dot(g01, vec2(fx.z, fy.z));
                    float n11 = dot(g11, vec2(fx.w, fy.w));
                    vec2 fade_xy = fade(Pf.xy);
                    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);
                    return 2.3 * mix(n_x.x, n_x.y, fade_xy.y);
                }

                const int OCTAVES = 8;
                float fbm(vec2 p, float waveFrequency, float waveAmplitude) {
                    float value = 0.0;
                    float amp = 1.0;
                    float freq = waveFrequency;
                    for (int i = 0; i < OCTAVES; i++) {
                        value += amp * abs(cnoise(p));
                        p *= freq;
                        amp *= waveAmplitude;
                    }
                    return value;
                }

                float pattern(vec2 p, float time, float waveSpeed, float waveFrequency, float waveAmplitude) {
                    vec2 p2 = p - time * waveSpeed;
                    return fbm(p - fbm(p + fbm(p2, waveFrequency, waveAmplitude), waveFrequency, waveAmplitude), waveFrequency, waveAmplitude);
                }

                float bayerMatrix8x8(int x, int y) {
                    const int matrix[64] = int[64](
                        0, 48, 12, 60, 3, 51, 15, 63,
                        32, 16, 44, 28, 35, 19, 47, 31,
                        8, 56, 4, 52, 11, 59, 7, 55,
                        40, 24, 36, 20, 43, 27, 39, 23,
                        2, 50, 14, 62, 1, 49, 13, 61,
                        34, 18, 46, 30, 33, 17, 45, 29,
                        10, 58, 6, 54, 9, 57, 5, 53,
                        42, 26, 38, 22, 41, 25, 37, 21
                    );
                    return float(matrix[y * 8 + x]) / 64.0;
                }

                vec3 dither(vec2 fragCoord, vec3 color, float colorNum) {
                    int x = int(fragCoord.x) % 8;
                    int y = int(fragCoord.y) % 8;
                    float threshold = bayerMatrix8x8(x, y) - 0.25;
                    color += threshold;
                    return floor(color * (colorNum - 1.0) + 0.5) / (colorNum - 1.0);
                }

                void main() {
                    vec2 uv = gl_FragCoord.xy / iResolution.xy;
                    uv -= 0.5;
                    uv.x *= iResolution.x / iResolution.y;
                    
                    vec3 lightBlue = vec3(0.13, 0.5, 0.85);
                    vec3 pink = vec3(1.0, 0.2, 0.5);
                    vec3 white = vec3(0.8, 0.9, 1.0);
                    
                    vec3 col = white;
                    
                    // æ³¢ç´‹ã®å¹²æ¸‰ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è“„ç©
                    float totalWaveHeight = 0.0;
                    vec2 flowField = vec2(0.0);
                    vec3 accumulatedColor = vec3(0.0);
                    float totalColorWeight = 0.0;
                    
                    // å„æ°´æ»´ã‹ã‚‰ã®æ°¸ç¶šçš„ãªæ³¢ç´‹
                    for (int i = 0; i < dropletCount && i < ${MAX_DROPLETS}; i++) {
                        vec4 droplet = droplets[i];
                        vec2 dropPos = droplet.xy;
                        float dropTime = droplet.z;
                        float dropType = droplet.w;
                        
                        float elapsed = iTime - dropTime;
                        
                        if (elapsed >= 0.0) {
                            float dist = length(uv - dropPos);
                            
                            // ãƒ©ãƒ³ãƒ€ãƒ ã‚µã‚¤ã‚º
                            float sizeRandom = fract(sin(dropTime * 12.9898) * 43758.5453);
                            float sizeScale = 0.5 + sizeRandom * 1.0;
                            
                            float baseSpeed = 0.075; // é€Ÿåº¦åŠåˆ†
                            float baseSize = 0.033 * sizeScale; // ã‚µã‚¤ã‚º1/3
                            
                            // æ°¸ç¶šçš„ãªæ³¢ç´‹ï¼ˆæ¶ˆãˆãªã„ï¼‰
                            int numRipples = 5 + int(sizeRandom * 3.0);
                            float rippleWaveHeight = 0.0;
                            
                            for (int r = 0; r < 7; r++) {
                                if (r >= numRipples) break;
                                
                                float rippleDelay = float(r) * 0.15;
                                float rippleElapsed = elapsed - rippleDelay;
                                
                                if (rippleElapsed > 0.0) {
                                    float rippleRadius = rippleElapsed * baseSpeed;
                                    float rippleWidth = baseSize * 0.8;
                                    
                                    // æ³¢ç´‹ã®é«˜ã•ï¼ˆæ­£å¼¦æ³¢ï¼‰
                                    float rippleDist = abs(dist - rippleRadius);
                                    float ripple = smoothstep(rippleWidth, rippleWidth * 0.3, rippleDist);
                                    
                                    // æ™‚é–“æ¸›è¡°ã‚’ç·©ã‚„ã‹ã«ï¼ˆé•·ãæ®‹ã‚‹ï¼‰
                                    float decay = exp(-rippleElapsed * 0.15);
                                    ripple *= decay;
                                    
                                    // æ³¢ã®ä½ç›¸
                                    float phase = sin(dist * 20.0 - rippleElapsed * 3.0) * ripple;
                                    rippleWaveHeight += phase * 0.4;
                                }
                            }
                            
                            totalWaveHeight += rippleWaveHeight;
                            
                            // æ³¢ç´‹ã«ã‚ˆã‚‹æµã‚Œå ´ã®ç”Ÿæˆï¼ˆæ³¢ãŒé€²ã‚€æ–¹å‘ï¼‰
                            vec2 direction = normalize(uv - dropPos);
                            float flowStrength = abs(rippleWaveHeight) * 0.15;
                            flowField += direction * flowStrength;
                            
                            // è‰²ã®å½±éŸ¿
                            float colorRadius = elapsed * baseSpeed * 3.0;
                            float colorDecay = exp(-elapsed * 0.12);
                            float colorInfluence = smoothstep(colorRadius, colorRadius * 0.1, dist) * colorDecay;
                            
                            if (colorInfluence > 0.01) {
                                vec3 dropColor = (dropType == 1.0) ? pink : lightBlue;
                                accumulatedColor += dropColor * colorInfluence;
                                totalColorWeight += colorInfluence;
                            }
                        }
                    }
                    
                    // æ³¢ç´‹ã®å¹²æ¸‰ãŒè“„ç©ã•ã‚Œã¦æµ·æµãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å½¢æˆ
                    if (abs(totalWaveHeight) > 0.1 || totalColorWeight > 0.1) {
                        // æµã‚Œå ´ã«ã‚ˆã£ã¦åº§æ¨™ã‚’æ­ªã‚ã‚‹
                        vec2 distortedUV = uv + flowField * 0.2;
                        
                        // æ³¢ã®å¹²æ¸‰å¼·åº¦ã«å¿œã˜ã¦æµ·æµãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ç”Ÿæˆ
                        float interferenceStrength = clamp(abs(totalWaveHeight) * 2.0, 0.0, 1.0);
                        
                        // æµ·æµé¢¨ãƒãƒ¼ãƒ–ãƒ«ãƒ‘ã‚¿ãƒ¼ãƒ³
                        float waveSpeed = 0.05;
                        float waveFrequency = 3.0 + interferenceStrength * 1.5;
                        float waveAmplitude = 0.3 + interferenceStrength * 0.15;
                        
                        // å¹²æ¸‰ãŒå¼·ã„ã»ã©ãƒãƒ¼ãƒ–ãƒ«æ¨¡æ§˜ãŒé¡•è‘—ã«
                        float marblePattern = pattern(
                            distortedUV + totalWaveHeight * 0.08, 
                            iTime, 
                            waveSpeed, 
                            waveFrequency, 
                            waveAmplitude
                        ) * interferenceStrength;
                        
                        // å˜ç´”ãªæ³¢ç´‹ã¨æµ·æµãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ãƒ–ãƒ¬ãƒ³ãƒ‰
                        float patternBlend = smoothstep(0.2, 0.8, interferenceStrength);
                        
                        if (totalColorWeight > 0.0) {
                            vec3 avgColor = accumulatedColor / totalColorWeight;
                            
                            // æµ·æµãƒ‘ã‚¿ãƒ¼ãƒ³ã«åŸºã¥ã3æ®µéšã®è‰²
                            float combinedPattern = mix(
                                fract(totalWaveHeight * 5.0) * 0.5 + 0.5, 
                                marblePattern, 
                                patternBlend
                            );
                            
                            vec3 darkColor = avgColor * 0.4;
                            vec3 midColor = avgColor * 0.7;
                            vec3 brightColor = avgColor * 1.0;
                            
                            vec3 finalColor;
                            if (combinedPattern < 0.33) {
                                finalColor = mix(darkColor, midColor, combinedPattern / 0.33);
                            } else if (combinedPattern < 0.66) {
                                finalColor = mix(midColor, brightColor, (combinedPattern - 0.33) / 0.33);
                            } else {
                                finalColor = mix(brightColor, white, (combinedPattern - 0.66) / 0.34);
                            }
                            
                            // æ³¢ç´‹ã®å¹²æ¸‰åº¦åˆã„ã«å¿œã˜ã¦è‰²ã‚’é©ç”¨
                            float colorIntensity = clamp(totalColorWeight * 0.7, 0.0, 1.0);
                            col = mix(white, finalColor, colorIntensity);
                        }
                    }
                    
                    // ãƒ‡ã‚£ã‚¶ãƒªãƒ³ã‚°
                    float colorNum = 4.0;
                    col = dither(gl_FragCoord.xy, col, colorNum);
                    
                    fragColor = vec4(col, 1.0);
                }
            `;

            function compileShader(source, type) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }
                return shader;
            }

            const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
            const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);

            if (!vertexShader || !fragmentShader) {
                return;
            }

            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program linking error:', gl.getProgramInfoLog(program));
                return;
            }

            gl.useProgram(program);

            const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
            const vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

            const positionLocation = gl.getAttribLocation(program, 'position');
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

            const iResolutionLocation = gl.getUniformLocation(program, 'iResolution');
            const iTimeLocation = gl.getUniformLocation(program, 'iTime');
            const dropletsLocation = gl.getUniformLocation(program, 'droplets');
            const dropletCountLocation = gl.getUniformLocation(program, 'dropletCount');

            function addDroplet(type) {
                const currentTime = performance.now() / 1000;
                const x = (Math.random() - 0.5) * 1.2;
                const y = (Math.random() - 0.5) * 1.2;

                if (droplets.length >= MAX_DROPLETS) {
                    droplets.shift();
                }

                droplets.push({ x, y, time: currentTime, type });
            }

            // å¤–éƒ¨ã‹ã‚‰å‘¼ã³å‡ºã™ãŸã‚ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«é–¢æ•°
            window.triggerPositiveEmotion = function () {
                addDroplet(1); // ãƒ”ãƒ³ã‚¯
            };
            window.triggerNegativeEmotion = function () {
                addDroplet(2); // ãƒ©ã‚¤ãƒˆãƒ–ãƒ«ãƒ¼
            };

            // ãƒ†ã‚¹ãƒˆç”¨ï¼šA / S ã‚­ãƒ¼ã§æ°´æ»´ã‚’ç™ºç”Ÿã•ã›ã‚‹
            document.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                if (key === 'a') {
                    window.triggerPositiveEmotion();
                } else if (key === 's') {
                    window.triggerNegativeEmotion();
                }
            });

            function render() {
                const time = performance.now() / 1000;
                
                gl.uniform2f(iResolutionLocation, canvas.width, canvas.height);
                gl.uniform1f(iTimeLocation, time);
                
                const dropletData = new Float32Array(MAX_DROPLETS * 4);
                for (let i = 0; i < droplets.length; i++) {
                    dropletData[i * 4 + 0] = droplets[i].x;
                    dropletData[i * 4 + 1] = droplets[i].y;
                    dropletData[i * 4 + 2] = droplets[i].time;
                    dropletData[i * 4 + 3] = droplets[i].type;
                }
                
                gl.uniform4fv(dropletsLocation, dropletData);
                gl.uniform1i(dropletCountLocation, droplets.length);
                
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                requestAnimationFrame(render);
            }

            render();
        })();
    </script>

    <!-- ãƒ›ãƒ¼ãƒ ç”»é¢ã‹ã‚‰ã®æ„Ÿæƒ…ã‚¤ãƒ™ãƒ³ãƒˆã‚’å—ã‘å–ã£ã¦èƒŒæ™¯ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’ç™ºç« -->
    <script src="/socket.io/socket.io.js"></script>
    <script>
        (function () {
            if (typeof io === 'undefined') return;
            const socket = io();
            const locationId = 'takeshiba-station';
            socket.emit('join-location', locationId);

            socket.on('mood-selected', (data) => {
                if (!data || !data.type) return;
                if (data.type === 'positive') {
                    if (window.triggerPositiveEmotion) window.triggerPositiveEmotion();
                } else if (data.type === 'negative') {
                    if (window.triggerNegativeEmotion) window.triggerNegativeEmotion();
                }
            });
        })();
    </script>

    <script>
        const haikusContainer = document.getElementById('haikus-container');

        // å·æŸ³ã‚’èª­ã¿è¾¼ã‚€
        async function loadHaikus() {
            try {
                const response = await fetch('/api/haikus');
                const data = await response.json();
                
                if (data.haikus && data.haikus.length > 0) {
                    displayHaikus(data.haikus);
                } else {
                    haikusContainer.innerHTML = '<div class="loading-message">ã¾ã å·æŸ³ãŒã‚ã‚Šã¾ã›ã‚“</div>';
                }
            } catch (error) {
                console.error('å·æŸ³èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
                haikusContainer.innerHTML = '<div class="error-message">å·æŸ³ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ</div>';
            }
        }

        // æ—¥æœ¬èªã®æ–‡å­—ã‚’éŸ³æ•°ã¨ã—ã¦ã‚«ã‚¦ãƒ³ãƒˆï¼ˆæ¦‚ç®—ï¼‰
        function countMorae(text) {
            // é•·éŸ³è¨˜å·ã‚„å°æ–‡å­—ã‚’è€ƒæ…®ã—ãŸç°¡æ˜“çš„ãªéŸ³æ•°ã‚«ã‚¦ãƒ³ãƒˆ
            let count = 0;
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                // ã²ã‚‰ãŒãªãƒ»ã‚«ã‚¿ã‚«ãƒŠãƒ»æ¼¢å­—ã¯åŸºæœ¬çš„ã«1éŸ³
                if (/[ã-ã‚“ã‚¡-ãƒ³ä¸€-é¾¯ã€…]/.test(char)) {
                    count++;
                }
                // é•·éŸ³è¨˜å·ã¯éŸ³æ•°ã«å«ã‚ãªã„ï¼ˆå‰ã®æ–‡å­—ã¨åˆã‚ã›ã¦1éŸ³ï¼‰
                else if (char === 'ãƒ¼' || char === 'âˆ’') {
                    // å‰ã®æ–‡å­—ã¨åˆã‚ã›ã¦1éŸ³ã¨ã—ã¦æ‰±ã†ãŸã‚ã€ã‚«ã‚¦ãƒ³ãƒˆã—ãªã„
                }
                // ãã®ä»–ã®æ–‡å­—ï¼ˆå¥èª­ç‚¹ã€ã‚¹ãƒšãƒ¼ã‚¹ãªã©ï¼‰ã¯éŸ³æ•°ã«å«ã‚ãªã„
            }
            return count;
        }

        // å·æŸ³ã‚’5-7-5ã®3è¡Œã«æ•´å½¢ã™ã‚‹é–¢æ•°
        function formatHaikuToThreeLines(haikuText) {
            if (!haikuText || haikuText.trim() === '') {
                return ['å·æŸ³ã‚’ç”Ÿæˆä¸­...', '', ''];
            }
            
            // æ—¢å­˜ã®æ”¹è¡ŒãŒã‚ã‚‹å ´åˆã¯ã€ãã®æ”¹è¡Œã‚’ä¿æŒã—ã¦ç¢ºèª
            const originalLines = haikuText.trim().split(/[\n\r]+/).filter(line => line.trim() !== '');
            
            // æ—¢ã«3è¡Œã«ãªã£ã¦ã„ã¦ã€5-7-5ã«è¿‘ã„å ´åˆã¯ãã®ã¾ã¾ä½¿ç”¨
            if (originalLines.length === 3) {
                const count1 = countMorae(originalLines[0]);
                const count2 = countMorae(originalLines[1]);
                const count3 = countMorae(originalLines[2]);
                // 5-7-5ã«è¿‘ã„å ´åˆï¼ˆè¨±å®¹ç¯„å›²ï¼šÂ±2éŸ³ï¼‰
                if (Math.abs(count1 - 5) <= 2 && Math.abs(count2 - 7) <= 2 && Math.abs(count3 - 5) <= 2) {
                    return originalLines;
                }
            }
            
            // æ—¢å­˜ã®æ”¹è¡Œã‚’é™¤å»ã—ã¦1è¡Œã«
            const cleaned = haikuText.trim().replace(/\s+/g, '').replace(/[\n\r]+/g, '');
            
            if (cleaned.length === 0) {
                return ['', '', ''];
            }
            
            // å…¨ä½“ã®æ–‡å­—åˆ—ã‹ã‚‰5-7-5ã«åˆ†å‰²
            const totalLength = cleaned.length;
            // 5:7:5ã®æ¯”ç‡ã§åˆ†å‰²ï¼ˆå…¨ä½“ãŒ17éŸ³ã‚’æƒ³å®šï¼‰
            const ratio1 = 5 / 17;  // æœ€åˆã®5éŸ³åˆ†
            const ratio2 = 12 / 17; // æœ€åˆã®12éŸ³åˆ†ï¼ˆ5+7ï¼‰
            
            let pos1 = Math.floor(totalLength * ratio1);
            let pos2 = Math.floor(totalLength * ratio2);
            
            // å¥èª­ç‚¹ã‚„åˆ‡ã‚Œå­—ã®è¿‘ãã§èª¿æ•´
            const findBestSplitPoint = (targetPos, text, range = 5) => {
                let bestPos = targetPos;
                let bestDistance = range;
                
                // ã¾ãšå¥èª­ç‚¹ã‚„åˆ‡ã‚Œå­—ã®å¾Œã‚’æ¢ã™
                for (let i = Math.max(0, targetPos - range); i < Math.min(text.length, targetPos + range); i++) {
                    if (/[ã€ã€‚ã‚„ã‹ãªã‘ã‚Šãªã‚Š]/.test(text[i])) {
                        const distance = Math.abs(targetPos - i);
                        if (distance < bestDistance) {
                            bestDistance = distance;
                            bestPos = i + 1;
                        }
                    }
                }
                
                // è¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯ã€ç©ºç™½ã‚„åŒºåˆ‡ã‚Šæ–‡å­—ã®å¾Œã‚’æ¢ã™
                if (bestPos === targetPos) {
                    for (let i = Math.max(0, targetPos - range); i < Math.min(text.length, targetPos + range); i++) {
                        if (/[\sã€€]/.test(text[i])) {
                            const distance = Math.abs(targetPos - i);
                            if (distance < bestDistance) {
                                bestDistance = distance;
                                bestPos = i + 1;
                            }
                        }
                    }
                }
                
                return bestPos;
            };
            
            pos1 = findBestSplitPoint(pos1, cleaned);
            pos2 = findBestSplitPoint(pos2, cleaned, 8);
            
            // 3è¡Œã«åˆ†å‰²ï¼ˆå¿…ãš3è¡Œã«ãªã‚‹ã‚ˆã†ã«ã™ã‚‹ï¼‰
            const line1 = cleaned.substring(0, pos1).trim() || '';
            const line2 = cleaned.substring(pos1, pos2).trim() || '';
            const line3 = cleaned.substring(pos2).trim() || '';
            
            // ç©ºè¡ŒãŒå«ã¾ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€å‡ç­‰ã«å†åˆ†é…
            if (!line1 || !line2 || !line3) {
                // å…¨ä½“ã‚’3ç­‰åˆ†ã™ã‚‹
                const part1 = Math.ceil(totalLength / 3);
                const part2 = Math.ceil(totalLength * 2 / 3);
                return [
                    cleaned.substring(0, part1).trim() || '',
                    cleaned.substring(part1, part2).trim() || '',
                    cleaned.substring(part2).trim() || ''
                ];
            }
            
            return [line1, line2, line3];
        }

        // ã„ã„ã­ãƒœã‚¿ãƒ³ã®ã‚¯ãƒªãƒƒã‚¯å‡¦ç†
        async function handleLikeClick(haikuId, likeBtn) {
            try {
                // ãƒœã‚¿ãƒ³ã‚’ç„¡åŠ¹åŒ–
                likeBtn.disabled = true;
                
                const response = await fetch(`/api/haiku/${haikuId}/like`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                const result = await response.json();
                
                if (result.success) {
                    // UIã‚’æ›´æ–°
                    const likeIcon = likeBtn.querySelector('.like-icon');
                    const likeCount = likeBtn.querySelector('.like-count');
                    
                    if (result.liked) {
                        likeBtn.classList.add('liked');
                        likeIcon.textContent = 'â¤ï¸';
                    } else {
                        likeBtn.classList.remove('liked');
                        likeIcon.textContent = 'ğŸ¤';
                    }
                    
                    likeCount.textContent = result.count;
                } else {
                    console.error('ã„ã„ã­å‡¦ç†ã‚¨ãƒ©ãƒ¼:', result.error);
                }
            } catch (error) {
                console.error('ã„ã„ã­å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
            } finally {
                // ãƒœã‚¿ãƒ³ã‚’å†æœ‰åŠ¹åŒ–
                likeBtn.disabled = false;
            }
        }

        // moodæƒ…å ±ã‹ã‚‰ç›´æ¥èƒŒæ™¯ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’ç™ºç«
        function triggerEmotionEffectFromMood(mood) {
            if (!mood) return;
            
            const moodLower = (mood || '').toLowerCase();
            
            // ãƒ—ãƒ©ã‚¹æ„Ÿæƒ…ã¨ãƒã‚¤ãƒŠã‚¹æ„Ÿæƒ…ã®åˆ†é¡
            const positiveMoods = [
                'exhilarated', 'excited', 'inspired', 'joyful',
                'calm', 'relaxed', 'content', 'hopeful',
                'happy', 'peaceful', 'energetic', 'nostalgic', 'contemplative', 'surprised'
            ];
            const negativeMoods = [
                'melancholy', 'lonely', 'tired', 'apathetic',
                'anxious', 'tense', 'irritated'
            ];

            if (positiveMoods.includes(moodLower)) {
                if (window.triggerPositiveEmotion) {
                    window.triggerPositiveEmotion();
                    console.log('ãƒã‚¸ãƒ†ã‚£ãƒ–æ„Ÿæƒ…ã‚¨ãƒ•ã‚§ã‚¯ãƒˆç™ºç«:', mood);
                }
            } else if (negativeMoods.includes(moodLower)) {
                if (window.triggerNegativeEmotion) {
                    window.triggerNegativeEmotion();
                    console.log('ãƒã‚¬ãƒ†ã‚£ãƒ–æ„Ÿæƒ…ã‚¨ãƒ•ã‚§ã‚¯ãƒˆç™ºç«:', mood);
                }
            }
        }

        // å·æŸ³ã‚’è¡¨ç¤º
        function displayHaikus(haikus) {
            if (!haikus || haikus.length === 0) {
                haikusContainer.innerHTML = '<div class="loading-message">ã¾ã å·æŸ³ãŒã‚ã‚Šã¾ã›ã‚“</div>';
                return;
            }
            
            // æ–°ã—ã„é †ã«ã‚½ãƒ¼ãƒˆï¼ˆæ—¢ã«ã‚µãƒ¼ãƒãƒ¼å´ã§ã‚½ãƒ¼ãƒˆæ¸ˆã¿ã ãŒã€å¿µã®ãŸã‚ï¼‰
            haikus.sort((a, b) => new Date(b.created_at || b.timestamp) - new Date(a.created_at || a.timestamp));
            
            // æ—¢å­˜ã®å·æŸ³IDã‚’å–å¾—ï¼ˆé‡è¤‡ãƒã‚§ãƒƒã‚¯ç”¨ï¼‰
            const existingIds = new Set();
            const existingCards = haikusContainer.querySelectorAll('.haiku-display-card');
            existingCards.forEach(card => {
                const id = card.dataset.haikuId;
                if (id) existingIds.add(id);
            });
            
            // æœ€æ–°20ä»¶ã®å·æŸ³ã‚’è¡¨ç¤ºï¼ˆã‚µãƒ¼ãƒãƒ¼å´ã§æ—¢ã«åˆ¶é™æ¸ˆã¿ï¼‰
            haikus.forEach(haiku => {
                const haikuId = haiku.id;
                const isNewHaiku = haikuId && !existingIds.has(haikuId.toString());
                
                // æ–°ã—ã„å·æŸ³ã®å ´åˆã€moodã«åŸºã¥ã„ã¦Effectã‚’ç™ºç«
                if (isNewHaiku && haiku.mood) {
                    triggerEmotionEffectFromMood(haiku.mood);
                }
                
                // æ—¢ã«è¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹å·æŸ³ã®å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—ï¼ˆé‡è¤‡è¡¨ç¤ºã‚’é˜²ãï¼‰
                if (haikuId && existingIds.has(haikuId.toString())) {
                    return;
                }
                
                const card = document.createElement('div');
                card.className = 'haiku-display-card';
                if (haikuId) {
                    card.dataset.haikuId = haikuId.toString();
                }
                
                const date = new Date(haiku.created_at || haiku.timestamp);
                const formattedDate = date.toLocaleString('ja-JP', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
                
                // å·æŸ³ã‚’5-7-5ã®3è¡Œã«æ•´å½¢ï¼ˆé…åˆ—ã§è¿”ã•ã‚Œã‚‹ï¼‰
                const lines = formatHaikuToThreeLines(haiku.haiku);
                
                // ç©ºè¡Œã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã—ã¦ã€å¿…ãš3è¡Œã«ãªã‚‹ã‚ˆã†ã«ã™ã‚‹
                const validLines = lines.filter(line => line && line.trim() !== '');
                const finalLines = validLines.length >= 3 ? validLines.slice(0, 3) : 
                                  validLines.length === 2 ? [...validLines, ''] :
                                  validLines.length === 1 ? [validLines[0], '', ''] : ['', '', ''];
                
                // ç¸¦æ›¸ãè¡¨ç¤ºç”¨ã«å„è¡Œã‚’ç¸¦ã«é…ç½®ï¼ˆå³ã‹ã‚‰å·¦ã«è¡¨ç¤ºã•ã‚Œã‚‹ã‚ˆã†ã«é †åºã‚’ä¿æŒï¼‰
                const penname = haiku.penname || 'è© ã¿äººçŸ¥ã‚‰ãš';
                const likesCount = haiku.likes_count || 0;
                const isLiked = haiku.liked || false;
                
                card.innerHTML = `
                    <div class="haiku-display-text">
                        ${finalLines.map((line, index) => `<span class="haiku-line" data-line="${index + 1}">${line || ''}</span>`).join('')}
                    </div>
                    <div class="haiku-display-meta">
                        <div class="haiku-penname">âœï¸ ${penname}</div>
                        <div class="haiku-timestamp">${formattedDate}</div>
                    </div>
                    ${haikuId ? `
                    <div class="haiku-display-actions">
                        <button class="like-btn ${isLiked ? 'liked' : ''}" data-haiku-id="${haikuId}">
                            <span class="like-icon">${isLiked ? 'â¤ï¸' : 'ğŸ¤'}</span>
                            <span class="like-count">${likesCount}</span>
                        </button>
                    </div>
                    ` : ''}
                `;
                
                // ã„ã„ã­ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ ï¼ˆã‚¹ãƒ¯ã‚¤ãƒ—ã¨ã‚¿ãƒƒãƒ—ã‚’åŒºåˆ¥ï¼‰
                if (haikuId) {
                    const likeBtn = card.querySelector('.like-btn');
                    if (likeBtn) {
                        let touchStartX = 0;
                        let touchStartY = 0;
                        let touchStartTime = 0;
                        const SWIPE_THRESHOLD = 10; // ã‚¹ãƒ¯ã‚¤ãƒ—ã¨åˆ¤å®šã™ã‚‹ç§»å‹•è·é›¢ï¼ˆpxï¼‰
                        const TAP_TIME_THRESHOLD = 300; // ã‚¿ãƒƒãƒ—ã¨åˆ¤å®šã™ã‚‹æ™‚é–“ï¼ˆmsï¼‰
                        
                        // ã‚¿ãƒƒãƒé–‹å§‹
                        likeBtn.addEventListener('touchstart', function(e) {
                            const touch = e.touches[0];
                            touchStartX = touch.clientX;
                            touchStartY = touch.clientY;
                            touchStartTime = Date.now();
                        }, { passive: true });
                        
                        // ã‚¿ãƒƒãƒçµ‚äº†ï¼ˆã‚¿ãƒƒãƒ—åˆ¤å®šï¼‰
                        likeBtn.addEventListener('touchend', async function(e) {
                            const touch = e.changedTouches[0];
                            const touchEndX = touch.clientX;
                            const touchEndY = touch.clientY;
                            const touchEndTime = Date.now();
                            
                            // ç§»å‹•è·é›¢ã‚’è¨ˆç®—
                            const deltaX = Math.abs(touchEndX - touchStartX);
                            const deltaY = Math.abs(touchEndY - touchStartY);
                            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                            const touchDuration = touchEndTime - touchStartTime;
                            
                            // ã‚¹ãƒ¯ã‚¤ãƒ—ã§ãªã„å ´åˆï¼ˆç§»å‹•è·é›¢ãŒé–¾å€¤ä»¥ä¸‹ï¼‰ã®ã¿ã‚¯ãƒªãƒƒã‚¯ã¨ã—ã¦å‡¦ç†
                            if (distance <= SWIPE_THRESHOLD && touchDuration <= TAP_TIME_THRESHOLD) {
                                e.preventDefault();
                                e.stopPropagation();
                                await handleLikeClick(haikuId, likeBtn);
                            }
                        }, { passive: false });
                        
                        // ãƒã‚¦ã‚¹ã‚¯ãƒªãƒƒã‚¯ï¼ˆãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—ç”¨ï¼‰
                        likeBtn.addEventListener('click', async function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            await handleLikeClick(haikuId, likeBtn);
                        });
                    }
                }
                
                haikusContainer.appendChild(card);
            });
        }

        // åˆæœŸèª­ã¿è¾¼ã¿
        loadHaikus();

        // å®šæœŸçš„ã«æ›´æ–°ï¼ˆ30ç§’ã”ã¨ï¼‰
        setInterval(loadHaikus, 30000);
    </script>
</body>
</html>

